
%option prefix="mcsh_expr_"
%option noyywrap

%{
  #include <stdbool.h>
  #include <stdio.h>
  // Generated by bison:
  #include "mcsh-expr-parser.h"
  #include "mcsh-expr-grammar.h"
%}

STRINGLITERAL ["](([\\]["])|([^"]))*["]

  bool mcsh_expr_token_quoted;

%%

[ \t]           ;

{STRINGLITERAL} {
  mcsh_expr_token_quoted = true;
  mcsh_expr_lval.sval = strdup(mcsh_expr_text);
  return TOKEN;
}

\n { mcsh_expr_line++; return NL; }
";" { return SEMICOLON; }

"+" { /* printf("flex: PLUS\n");  */ return PLUS;  }
"-" { /* printf("flex: MINUS\n"); */ return MINUS; }
"*" { /* printf("flex: MULT\n");  */ return MULT;  }
"/" { /* printf("flex: DIV\n");   */ return DIV;   }
"%/" { /* printf("flex: IDIV\n");   */ return IDIV;   }
"%" { /* printf("flex: MOD\n");   */ return MOD;   }
"(" { return LPAREN; }
")" { return RPAREN; }

"==" { return EQ; }
"!=" { return NE; }
"<"  { return LT; }
">"  { return GT; }
"<=" { return LE; }
">=" { return GE; }

"?" { return QM; }
":" { return COLON; }

[\-_$#@a-zA-Z0-9.]+ {
  // printf("flex TOKEN: %s\n", mcsh_expr_text);
  mcsh_expr_token_quoted = false;
  mcsh_expr_lval.sval = strdup(mcsh_expr_text);
  return TOKEN;
}

<<EOF>> { return END; }

%%

/* TOKEN:       { */

void
mcsh_expr_source_set(char* text)
{
  mcsh_expr_line = 1;
  yy_scan_string(text);
}

void
mcsh_expr_clean(void)
{
  printf("mcsh_expr_clean.\n");
}

#if 0
"*" { return MULT;   }
#endif
